<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Email Thread Layouts - Multiple Views</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f8f9fa;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .layout-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .layout-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .layout-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .layout-title {
            font-size: 18px;
            font-weight: 600;
            margin: 0;
        }

        .layout-description {
            font-size: 12px;
            opacity: 0.9;
            margin: 2px 0 0 0;
        }

        .layout-viz {
            height: 400px;
            position: relative;
        }

        .layout-controls {
            display: flex;
            gap: 10px;
        }

        .control-btn {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }

        .control-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        /* Email Node Styles */
        .email-node {
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .email-node:hover {
            filter: brightness(1.2);
        }

        .email-circle {
            stroke: #fff;
            stroke-width: 2px;
        }

        .email-circle.original { fill: #4A90E2; }
        .email-circle.reply { fill: #28a745; }
        .email-circle.forward { fill: #ffc107; }
        .email-circle.external { fill: #dc3545; }

        .email-text {
            font-size: 9px;
            text-anchor: middle;
            pointer-events: none;
            fill: #333;
            font-weight: 600;
        }

        .connection-line {
            stroke: #adb5bd;
            stroke-width: 1.5px;
            fill: none;
            opacity: 0.7;
        }

        .connection-line.reply { stroke: #28a745; }
        .connection-line.forward { stroke: #ffc107; }

        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 8px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 11px;
            z-index: 1000;
            max-width: 200px;
        }

        .single-layout {
            grid-column: 1 / -1;
        }

        .layout-stats {
            padding: 15px 20px;
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
            font-size: 12px;
            color: #6c757d;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìß Email Thread Network Layouts</h1>
            <p>Compare different visualization approaches for the same email thread data</p>
            <p><strong>Thread:</strong> ALPHA-2024-001 ‚Ä¢ <strong>13 emails</strong> ‚Ä¢ <strong>10 participants</strong></p>
        </div>

        <div class="layout-grid">
            <!-- Layout 1: Hierarchical Tree -->
            <div class="layout-card">
                <div class="layout-header">
                    <div>
                        <h3 class="layout-title">üå≥ Hierarchical Tree</h3>
                        <p class="layout-description">Traditional parent-child relationships</p>
                    </div>
                    <div class="layout-controls">
                        <button class="control-btn" onclick="animateLayout('tree')">Animate</button>
                        <button class="control-btn" onclick="resetZoom('tree')">Reset</button>
                    </div>
                </div>
                <div class="layout-viz">
                    <svg id="tree-viz" width="100%" height="100%"></svg>
                </div>
                <div class="layout-stats">
                    <strong>Pros:</strong> Clear hierarchy, easy to follow conversation flow<br>
                    <strong>Cons:</strong> Can get wide with many branches
                </div>
            </div>

            <!-- Layout 2: Force-Directed Graph -->
            <div class="layout-card">
                <div class="layout-header">
                    <div>
                        <h3 class="layout-title">‚ö° Force-Directed</h3>
                        <p class="layout-description">Physics-based node positioning</p>
                    </div>
                    <div class="layout-controls">
                        <button class="control-btn" onclick="animateLayout('force')">Animate</button>
                        <button class="control-btn" onclick="resetZoom('force')">Reset</button>
                    </div>
                </div>
                <div class="layout-viz">
                    <svg id="force-viz" width="100%" height="100%"></svg>
                </div>
                <div class="layout-stats">
                    <strong>Pros:</strong> Natural clustering, dynamic positioning<br>
                    <strong>Cons:</strong> Can be chaotic, less predictable layout
                </div>
            </div>

            <!-- Layout 3: Circular/Radial -->
            <div class="layout-card">
                <div class="layout-header">
                    <div>
                        <h3 class="layout-title">üéØ Radial Layout</h3>
                        <p class="layout-description">Circular arrangement from center</p>
                    </div>
                    <div class="layout-controls">
                        <button class="control-btn" onclick="animateLayout('radial')">Animate</button>
                        <button class="control-btn" onclick="resetZoom('radial')">Reset</button>
                    </div>
                </div>
                <div class="layout-viz">
                    <svg id="radial-viz" width="100%" height="100%"></svg>
                </div>
                <div class="layout-stats">
                    <strong>Pros:</strong> Compact, shows central importance<br>
                    <strong>Cons:</strong> Harder to follow conversation threads
                </div>
            </div>

            <!-- Layout 4: Timeline Flow -->
            <div class="layout-card">
                <div class="layout-header">
                    <div>
                        <h3 class="layout-title">‚è∞ Timeline Flow</h3>
                        <p class="layout-description">Chronological with threading</p>
                    </div>
                    <div class="layout-controls">
                        <button class="control-btn" onclick="animateLayout('timeline')">Animate</button>
                        <button class="control-btn" onclick="resetZoom('timeline')">Reset</button>
                    </div>
                </div>
                <div class="layout-viz">
                    <svg id="timeline-viz" width="100%" height="100%"></svg>
                </div>
                <div class="layout-stats">
                    <strong>Pros:</strong> Shows time progression, intuitive flow<br>
                    <strong>Cons:</strong> Long threads can get stretched
                </div>
            </div>

            <!-- Layout 5: Grid Matrix -->
            <div class="layout-card">
                <div class="layout-header">
                    <div>
                        <h3 class="layout-title">üìä Grid Matrix</h3>
                        <p class="layout-description">Organized grid with connections</p>
                    </div>
                    <div class="layout-controls">
                        <button class="control-btn" onclick="animateLayout('grid')">Animate</button>
                        <button class="control-btn" onclick="resetZoom('grid')">Reset</button>
                    </div>
                </div>
                <div class="layout-viz">
                    <svg id="grid-viz" width="100%" height="100%"></svg>
                </div>
                <div class="layout-stats">
                    <strong>Pros:</strong> Very compact, easy to scan<br>
                    <strong>Cons:</strong> Connections can cross, less intuitive
                </div>
            </div>

            <!-- Layout 6: Sankey Flow -->
            <div class="layout-card">
                <div class="layout-header">
                    <div>
                        <h3 class="layout-title">üåä Sankey Flow</h3>
                        <p class="layout-description">Flow-based conversation streams</p>
                    </div>
                    <div class="layout-controls">
                        <button class="control-btn" onclick="animateLayout('sankey')">Animate</button>
                        <button class="control-btn" onclick="resetZoom('sankey')">Reset</button>
                    </div>
                </div>
                <div class="layout-viz">
                    <svg id="sankey-viz" width="100%" height="100%"></svg>
                </div>
                <div class="layout-stats">
                    <strong>Pros:</strong> Shows conversation volume, clear flow<br>
                    <strong>Cons:</strong> Complex for simple threads
                </div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip" style="opacity: 0;"></div>

    <script>
        // Sample email thread data
        const emailData = [
            { id: 1, from: "John Smith", subject: "Project Alpha - Initial Requirements", type: "original", time: "9:00", children: [2, 7, 12] },
            { id: 2, from: "Mary Jones", subject: "Re: Project Alpha - Initial Requirements", type: "reply", time: "9:15", children: [3, 4] },
            { id: 3, from: "Alice Brown", subject: "Re: Project Alpha - Initial Requirements", type: "reply", time: "9:30", children: [] },
            { id: 4, from: "Mary Jones", subject: "Fwd: Project Alpha - Initial Requirements", type: "forward", time: "10:00", children: [5] },
            { id: 5, from: "David Clark", subject: "Re: Fwd: Project Alpha - Initial Requirements", type: "reply", time: "10:30", children: [6] },
            { id: 6, from: "Alice Brown", subject: "Re: Fwd: Project Alpha - Mockups Ready", type: "reply", time: "11:00", children: [] },
            { id: 7, from: "Bob Wilson", subject: "Re: Project Alpha - Initial Requirements", type: "reply", time: "9:45", children: [8, 10] },
            { id: 8, from: "Bob Wilson", subject: "Re: Project Alpha - Initial Requirements", type: "reply", time: "10:15", children: [9] },
            { id: 9, from: "John Smith", subject: "Fwd: Project Alpha - Security Review Needed", type: "forward", time: "11:30", children: [11] },
            { id: 10, from: "Bob Wilson", subject: "Fwd: Project Alpha Database Architecture", type: "forward", time: "14:00", children: [13] },
            { id: 11, from: "Sarah White", subject: "Re: Fwd: Project Alpha - Security Review", type: "reply", time: "12:00", children: [] },
            { id: 12, from: "Mary Jones", subject: "Re: Project Alpha - Additional Thoughts", type: "reply", time: "15:00", children: [] },
            { id: 13, from: "Tom Smith", subject: "Re: Fwd: Project Alpha Database Architecture", type: "external", time: "14:30", children: [] }
        ];

        // Create links from parent-child relationships
        const links = [];
        emailData.forEach(email => {
            email.children.forEach(childId => {
                const child = emailData.find(e => e.id === childId);
                if (child) {
                    links.push({
                        source: email.id,
                        target: child.id,
                        type: child.type
                    });
                }
            });
        });

        const tooltip = d3.select("#tooltip");

        function showTooltip(event, d) {
            tooltip.style("opacity", 1)
                .html(`<strong>${d.subject}</strong><br>From: ${d.from}<br>Time: ${d.time}`)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 10) + "px");
        }

        function hideTooltip() {
            tooltip.style("opacity", 0);
        }

        // 1. HIERARCHICAL TREE LAYOUT
        function createTreeLayout() {
            const svg = d3.select("#tree-viz");
            const width = 750;
            const height = 400;
            const g = svg.append("g").attr("transform", "translate(40,20)");

            // Create hierarchy
            const root = d3.stratify()
                .id(d => d.id)
                .parentId(d => {
                    // Find parent
                    const parent = emailData.find(e => e.children.includes(d.id));
                    return parent ? parent.id : null;
                })(emailData);

            const tree = d3.tree().size([height - 40, width - 80]);
            tree(root);

            // Links
            g.selectAll(".link")
                .data(root.descendants().slice(1))
                .enter().append("path")
                .attr("class", "connection-line")
                .attr("d", d => `M${d.y},${d.x}C${(d.y + d.parent.y) / 2},${d.x} ${(d.y + d.parent.y) / 2},${d.parent.x} ${d.parent.y},${d.parent.x}`);

            // Nodes
            const node = g.selectAll(".node")
                .data(root.descendants())
                .enter().append("g")
                .attr("class", "email-node")
                .attr("transform", d => `translate(${d.y},${d.x})`)
                .on("mouseover", showTooltip)
                .on("mouseout", hideTooltip);

            node.append("circle")
                .attr("class", d => `email-circle ${d.data.type}`)
                .attr("r", 12);

            node.append("text")
                .attr("class", "email-text")
                .attr("dy", "0.31em")
                .text(d => d.data.from.split(' ').map(n => n[0]).join(''));
        }

        // 2. FORCE-DIRECTED LAYOUT
        function createForceLayout() {
            const svg = d3.select("#force-viz");
            const width = 750;
            const height = 400;
            const g = svg.append("g");

            const simulation = d3.forceSimulation(emailData)
                .force("link", d3.forceLink(links).id(d => d.id).distance(80))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collision", d3.forceCollide(20));

            const link = g.selectAll(".connection-line")
                .data(links)
                .enter().append("line")
                .attr("class", d => `connection-line ${d.type}`);

            const node = g.selectAll(".email-node")
                .data(emailData)
                .enter().append("g")
                .attr("class", "email-node")
                .on("mouseover", showTooltip)
                .on("mouseout", hideTooltip)
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            node.append("circle")
                .attr("class", d => `email-circle ${d.type}`)
                .attr("r", 12);

            node.append("text")
                .attr("class", "email-text")
                .attr("dy", "0.31em")
                .text(d => d.from.split(' ').map(n => n[0]).join(''));

            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node.attr("transform", d => `translate(${d.x},${d.y})`);
            });

            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        // 3. RADIAL LAYOUT
        function createRadialLayout() {
            const svg = d3.select("#radial-viz");
            const width = 750;
            const height = 400;
            const g = svg.append("g").attr("transform", `translate(${width/2},${height/2})`);

            const root = emailData.find(e => e.type === 'original');
            const others = emailData.filter(e => e.type !== 'original');

            // Position root at center
            root.x = 0;
            root.y = 0;

            // Position others in concentric circles
            others.forEach((email, i) => {
                const angle = (2 * Math.PI * i) / others.length;
                const radius = email.type === 'reply' ? 80 : 120;
                email.x = Math.cos(angle) * radius;
                email.y = Math.sin(angle) * radius;
            });

            // Links
            g.selectAll(".connection-line")
                .data(links)
                .enter().append("line")
                .attr("class", d => `connection-line ${d.type}`)
                .attr("x1", d => emailData.find(e => e.id === d.source).x)
                .attr("y1", d => emailData.find(e => e.id === d.source).y)
                .attr("x2", d => emailData.find(e => e.id === d.target).x)
                .attr("y2", d => emailData.find(e => e.id === d.target).y);

            // Nodes
            const node = g.selectAll(".email-node")
                .data(emailData)
                .enter().append("g")
                .attr("class", "email-node")
                .attr("transform", d => `translate(${d.x},${d.y})`)
                .on("mouseover", showTooltip)
                .on("mouseout", hideTooltip);

            node.append("circle")
                .attr("class", d => `email-circle ${d.type}`)
                .attr("r", 12);

            node.append("text")
                .attr("class", "email-text")
                .attr("dy", "0.31em")
                .text(d => d.from.split(' ').map(n => n[0]).join(''));
        }

        // 4. TIMELINE LAYOUT
        function createTimelineLayout() {
            const svg = d3.select("#timeline-viz");
            const width = 750;
            const height = 400;
            const g = svg.append("g").attr("transform", "translate(40,20)");

            // Sort by time
            const timeOrdered = [...emailData].sort((a, b) => a.time.localeCompare(b.time));

            timeOrdered.forEach((email, i) => {
                email.x = (i * (width - 80)) / (timeOrdered.length - 1);
                email.y = 50 + (email.type === 'reply' ? 0 : email.type === 'forward' ? 50 : 100);
            });

            // Links
            g.selectAll(".connection-line")
                .data(links)
                .enter().append("path")
                .attr("class", d => `connection-line ${d.type}`)
                .attr("d", d => {
                    const source = emailData.find(e => e.id === d.source);
                    const target = emailData.find(e => e.id === d.target);
                    return `M${source.x},${source.y}Q${(source.x + target.x)/2},${Math.min(source.y, target.y) - 30} ${target.x},${target.y}`;
                });

            // Timeline axis
            g.append("line")
                .attr("x1", 0)
                .attr("y1", height - 60)
                .attr("x2", width - 80)
                .attr("y2", height - 60)
                .attr("stroke", "#dee2e6")
                .attr("stroke-width", 2);

            // Time labels
            timeOrdered.forEach((email, i) => {
                if (i % 3 === 0) { // Show every 3rd time label
                    g.append("text")
                        .attr("x", email.x)
                        .attr("y", height - 40)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "10px")
                        .attr("fill", "#6c757d")
                        .text(email.time);
                }
            });

            // Nodes
            const node = g.selectAll(".email-node")
                .data(emailData)
                .enter().append("g")
                .attr("class", "email-node")
                .attr("transform", d => `translate(${d.x},${d.y})`)
                .on("mouseover", showTooltip)
                .on("mouseout", hideTooltip);

            node.append("circle")
                .attr("class", d => `email-circle ${d.type}`)
                .attr("r", 12);

            node.append("text")
                .attr("class", "email-text")
                .attr("dy", "0.31em")
                .text(d => d.from.split(' ').map(n => n[0]).join(''));
        }

        // 5. GRID LAYOUT
        function createGridLayout() {
            const svg = d3.select("#grid-viz");
            const width = 750;
            const height = 400;
            const g = svg.append("g").attr("transform", "translate(40,40)");

            const cols = 5;
            const cellWidth = (width - 80) / cols;
            const cellHeight = (height - 80) / Math.ceil(emailData.length / cols);

            emailData.forEach((email, i) => {
                email.x = (i % cols) * cellWidth + cellWidth / 2;
                email.y = Math.floor(i / cols) * cellHeight + cellHeight / 2;
            });

            // Links
            g.selectAll(".connection-line")
                .data(links)
                .enter().append("line")
                .attr("class", d => `connection-line ${d.type}`)
                .attr("x1", d => emailData.find(e => e.id === d.source).x)
                .attr("y1", d => emailData.find(e => e.id === d.source).y)
                .attr("x2", d => emailData.find(e => e.id === d.target).x)
                .attr("y2", d => emailData.find(e => e.id === d.target).y);

            // Nodes
            const node = g.selectAll(".email-node")
                .data(emailData)
                .enter().append("g")
                .attr("class", "email-node")
                .attr("transform", d => `translate(${d.x},${d.y})`)
                .on("mouseover", showTooltip)
                .on("mouseout", hideTooltip);

            node.append("circle")
                .attr("class", d => `email-circle ${d.type}`)
                .attr("r", 12);

            node.append("text")
                .attr("class", "email-text")
                .attr("dy", "0.31em")
                .text(d => d.from.split(' ').map(n => n[0]).join(''));
        }

        // 6. SANKEY LAYOUT
        function createSankeyLayout() {
            const svg = d3.select("#sankey-viz");
            const width = 750;
            const height = 400;
            const g = svg.append("g").attr("transform", "translate(60,40)");

            // Group emails by conversation depth
            const levels = {};
            function assignLevel(email, level = 0) {
                if (!levels[level]) levels[level] = [];
                levels[level].push(email);
                email.level = level;
                email.children.forEach(childId => {
                    const child = emailData.find(e => e.id === childId);
                    if (child) assignLevel(child, level + 1);
                });
            }

            const root = emailData.find(e => e.type === 'original');
            assignLevel(root);

            const maxLevel = Math.max(...Object.keys(levels).map(Number));
            const levelWidth = (width - 120) / maxLevel;

            Object.keys(levels).forEach(level => {
                levels[level].forEach((email, i) => {
                    email.x = level * levelWidth;
                    email.y = (i * (height - 80)) / (levels[level].length - 1 || 1) + 40;
                });
            });

            // Sankey-style connections
            g.selectAll(".connection-line")
                .data(links)
                .enter().append("path")
                .attr("class", d => `connection-line ${d.type}`)
                .attr("d", d => {
                    const source = emailData.find(e => e.id === d.source);
                    const target = emailData.find(e => e.id === d.target);
                    const midX = (source.x + target.x) / 2;
                    return `M${source.x},${source.y}C${midX},${source.y} ${midX},${target.y} ${target.x},${target.y}`;
                })
                .attr("stroke-width", 3)
                .attr("opacity", 0.6);

            // Nodes
            const node = g.selectAll(".email-node")
                .data(emailData)
                .enter().append("g")
                .attr("class", "email-node")
                .attr("transform", d => `translate(${d.x},${d.y})`)
                .on("mouseover", showTooltip)
                .on("mouseout", hideTooltip);

            node.append("rect")
                .attr("class", d => `email-circle ${d.type}`)
                .attr("x", -15)
                .attr("y", -10)
                .attr("width", 30)
                .attr("height", 20)
                .attr("rx", 4);

            node.append("text")
                .attr("class", "email-text")
                .attr("dy", "0.31em")
                .text(d => d.from.split(' ').map(n => n[0]).join(''));
        }

        // Initialize all layouts
        createTreeLayout();
        createForceLayout();
        createRadialLayout();
        createTimelineLayout();
        createGridLayout();
        createSankeyLayout();

        // Animation and reset functions
        function animateLayout(type) {
            // Add animation effects here
            console.log(`Animating ${type} layout`);
        }

        function resetZoom(type) {
            // Reset zoom for specific layout
            console.log(`Resetting ${type} layout`);
        }
    </script>
</body>
</html>